[{"categories":null,"content":"目标 在平时的开发过程中，调试代码是很重要的。对于调试，打印日志又是最常见，最快速的方式，本文研究redis中的日志模块。研究其中的使用方式。 ","date":"2021-11-08","objectID":"/log/:1:0","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"整体分析 redis中的日志模块写在了server.c中，没有独立成一个文件。本文以最小可运行的方式，抽离出日志模块，以及日志依赖的时间模块。 对于日志，redis封装了serverLog, 该方法第一个参数是日志等级，剩余参数会拼接成字符串。保持了和高级语言一样的方式。可以把日志输出到stdout, 也可以输出到指定文件。 日志中会包含时间，redis又封装了不同精度的时间。 主要关注unix时间戳。它支持原子操作。 ","date":"2021-11-08","objectID":"/log/:2:0","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"源代码 源码 ","date":"2021-11-08","objectID":"/log/:3:0","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"准备工作：从redis源码中拷贝代码 cp /home/vagrant/github/server_installer/servers/redis/redis-6.2/src/localtime.c . cp /home/vagrant/github/server_installer/servers/redis/redis-6.2/src/atomicvar.h . ","date":"2021-11-08","objectID":"/log/:3:1","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"新建server.c #include \"stdio.h\"#include \"server.h\"#include \u003csys/time.h\u003e#include \u003csyslog.h\u003e#include \u003cstdarg.h\u003e #define NET_IP_STR_LEN 46 /* INET6_ADDRSTRLEN is 46, but we need to be sure */struct redisServer server; /* * Gets the proper timezone in a more portable fashion * i.e timezone variables are linux specific. */ long getTimeZone(void) { #if defined(__linux__) || defined(__sun) return timezone; #else struct timeval tv; struct timezone tz; gettimeofday(\u0026tv, \u0026tz); return tz.tz_minuteswest * 60L; #endif } /* We take a cached value of the unix time in the global state because with * virtual memory and aging there is to store the current time in objects at * every object access, and accuracy is not needed. To access a global var is * a lot faster than calling time(NULL). * * This function should be fast because it is called at every command execution * in call(), so it is possible to decide if to update the daylight saving * info or not using the 'update_daylight_info' argument. Normally we update * such info only when calling this function from serverCron() but not when * calling it from call(). */ void updateCachedTime(int update_daylight_info) { server.ustime = ustime(); server.mstime = server.ustime / 1000; time_t unixtime = server.mstime / 1000; atomicSet(server.unixtime, unixtime); /* To get information about daylight saving time, we need to call * localtime_r and cache the result. However calling localtime_r in this * context is safe since we will never fork() while here, in the main * thread. The logging function will call a thread safe version of * localtime that has no locks. */ if (update_daylight_info) { struct tm tm; time_t ut = server.unixtime; localtime_r(\u0026ut,\u0026tm); server.daylight_active = tm.tm_isdst; } } /* Return the UNIX time in microseconds */ long long ustime(void) { struct timeval tv; long long ust; gettimeofday(\u0026tv, NULL); ust = ((long long)tv.tv_sec)*1000000; ust += tv.tv_usec; return ust; } void initServerConfig(void) { updateCachedTime(1); server.timezone = getTimeZone(); } int main() { tzset(); initServerConfig(); server.sentinel_mode = 0; server.masterhost = NULL; //server.logfile = \"/tmp/server.log\"; server.logfile = \"\"; server.verbosity = 0; server.syslog_enabled = 1; serverLog(LL_WARNING, \" Redis is starting unixtime is: %ld\", server.unixtime); } /* Like serverLogRaw() but with printf-alike support. This is the function that * is used across the code. The raw version is only used in order to dump * the INFO output on crash. */ void _serverLog(int level, const char *fmt, ...) { va_list ap; char msg[LOG_MAX_LEN]; va_start(ap, fmt); vsnprintf(msg, sizeof(msg), fmt, ap); va_end(ap); serverLogRaw(level,msg); } /*============================ Utility functions ============================ */ /* We use a private localtime implementation which is fork-safe. The logging * function of Redis may be called from other threads. */ void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst); /* Low level logging. To use only for very big messages, otherwise * serverLog() is to prefer. */ void serverLogRaw(int level, const char *msg) { const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING }; const char *c = \".-*#\"; FILE *fp; char buf[64]; int rawmode = (level \u0026 LL_RAW); int log_to_stdout = server.logfile[0] == '\\0'; level \u0026= 0xff; /* clear flags */ if (level \u003c server.verbosity) return; fp = log_to_stdout ? stdout : fopen(server.logfile,\"a\"); if (!fp) return; if (rawmode) { fprintf(fp,\"%s\",msg); } else { int off; struct timeval tv; int role_char; pid_t pid = getpid(); gettimeofday(\u0026tv,NULL); struct tm tm; nolocks_localtime(\u0026tm,tv.tv_sec,server.timezone,server.daylight_active); off = strftime(buf,sizeof(buf),\"%d %b %Y %H:%M:%S.\",\u0026tm); snprintf(buf+off,sizeof(buf)-off,\"%03d\",(int)tv.tv_usec/1000); if (server.sentinel_mode) { role_char = 'X'; /* Sentinel. */ } else if (pid != server.pid) { role_char = 'C'; /* RDB / AOF writing child. */ } else { role_char = (server.masterhost ? 'S':'M'); ","date":"2021-11-08","objectID":"/log/:3:2","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"新建server.h #include \u003cfcntl.h\u003e#include \u003ctime.h\u003e#include \"atomicvar.h\"#include \u003cunistd.h\u003e#define LOG_MAX_LEN 1024 /* Default maximum length of syslog messages.*/ typedef long long ustime_t; /* microsecond time type. */ typedef long long mstime_t; /* millisecond time type. */ long long ustime(void); /* Log levels */ #define LL_DEBUG 0 #define LL_VERBOSE 1 #define LL_NOTICE 2 #define LL_WARNING 3 #define LL_RAW (1\u003c\u003c10) /* Modifier to log without timestamp */ /* Use macro for checking log level to avoid evaluating arguments in cases log * should be ignored due to low level. */ #define serverLog(level, ...) do {\\ if (((level)\u00260xff) \u003c server.verbosity) break;\\ _serverLog(level, __VA_ARGS__);\\ } while(0) #ifdef __GNUC__ void _serverLog(int level, const char *fmt, ...) __attribute__((format(printf, 2, 3))); #else void _serverLog(int level, const char *fmt, ...); #endif void serverLogRaw(int level, const char *msg); struct redisServer { pid_t pid; /* Main process pid. */ char *masterhost; /* Hostname of master */ int sentinel_mode; /* True if this instance is a Sentinel. */ char *logfile; /* Path of log file */ int syslog_enabled; /* Is syslog enabled? */ int verbosity; /* Loglevel in redis.conf */ time_t timezone; /* Cached timezone. As set by tzset(). */ int daylight_active; /* Currently in daylight saving time. */ mstime_t mstime; /* 'unixtime' in milliseconds. */ ustime_t ustime; /* 'unixtime' in microseconds. */ redisAtomic time_t unixtime; /* Unix time sampled every cron cycle. */ }; 在redisServer中，因为在log中使用，所有需要加了一些看似没有用属性。这一点redis做的不是很好，业务和库耦合了。redisServer可以理解为有状态的容器，需要全局有效，共享的，都可以加到这上面来。在函数中直接访问属性就可以了。 ","date":"2021-11-08","objectID":"/log/:3:3","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"新建 Makefile all: server @echo \"anet demo\" server : server.o localtime.o $(CC) -o $@ $^ .PHONY: clean clean: rm -rf *.o *.d server client ","date":"2021-11-08","objectID":"/log/:3:4","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"输出 执行make后生成server可执行文件， 执行server后输出 279214:C 08 Nov 2021 15:19:27.074 # Redis is starting unixtime is: 1636355967 ","date":"2021-11-08","objectID":"/log/:3:5","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"使用到的api serverLog(level, …) ","date":"2021-11-08","objectID":"/log/:3:6","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"文章思路 动手实践是最快的学习方式。用能理解的方式，轻松的学习Redis，借鉴Redis， 并应用。 不过分关注细节，从Api入手 ","date":"2021-11-08","objectID":"/log/:3:7","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"码字不易，感谢点赞 ","date":"2021-11-08","objectID":"/log/:3:8","tags":null,"title":"Redis源码-4 日志和时间","uri":"/log/"},{"categories":null,"content":"目标 在Redis源码-3 网络编程, 学习了redis封装的网络库。其中用了循环不断去执行anetTcpAccept, 这是机制效率差，为了提高程序的并发数，操作系统引入了epoll等类似的机制，避免了死等，可以做到当事件发生时通知用户。Redis没有才用现有的异步库，自研了一个适合redis的库。比较小巧，适合学习。本文引入Redis中的ae模块，改造之前的流程。 ","date":"2021-11-08","objectID":"/ae/:1:0","tags":null,"title":"Redis源码-5 异步事件","uri":"/ae/"},{"categories":null,"content":"可运行代码 源码 ","date":"2021-11-08","objectID":"/ae/:2:0","tags":null,"title":"Redis源码-5 异步事件","uri":"/ae/"},{"categories":null,"content":"准备工作：从redis源码中拷贝代码 cp /home/vagrant/github/server_installer/servers/redis/redis-6.2/src/ae* . ... ","date":"2021-11-08","objectID":"/ae/:2:1","tags":null,"title":"Redis源码-5 异步事件","uri":"/ae/"},{"categories":null,"content":"修改server.c #include \"anet.h\"#include \"zmalloc.h\"#include \u003csys/socket.h\u003e#include \u003cunistd.h\u003e#include \"sys/socket.h\"#define NET_IP_STR_LEN 46 /* INET6_ADDRSTRLEN is 46, but we need to be sure */#include \"ae.h\" void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask); #define MAX_ACCEPTS_PER_CALL 1000 #define UNUSED(V) ((void) V) void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) { int cport, cfd, max = MAX_ACCEPTS_PER_CALL; char cip[NET_IP_STR_LEN]; UNUSED(el); UNUSED(mask); UNUSED(privdata); while(max--) { char* neterr; neterr = zmalloc(100); cfd = anetTcpAccept(neterr, fd, cip, sizeof(cip), \u0026cport); if (cfd == ANET_ERR) { continue; } anetCloexec(cfd); printf(\"accept...%d\\n\",cfd); char buf[1024]; recv(cfd, buf, sizeof(buf), MSG_WAITALL); printf(\"recv from %s:%d %s\\n\",cip, cport, buf); close(cfd); } } int main() { // 错误信息 char *neterr = zmalloc(10); printf(\"staring...\\n\"); aeEventLoop *el; el = aeCreateEventLoop(100); // 端口6380 int serverSocket = anetTcpServer(neterr, 6380,\"*\" , 2); if ( ! neterr ) { printf(\"start err %s \\n\", neterr); return 1; } printf(\"listening...%d \\n\",serverSocket ); if (aeCreateFileEvent(el, serverSocket, AE_READABLE, acceptTcpHandler,NULL) == AE_ERR) { aeDeleteFileEvent(el, serverSocket, AE_READABLE); return 1; } aeMain(el); aeDeleteEventLoop(el); return 0; } 去掉了while(1)循环，调用anetTcpServer创建事件循环，调用aeCreateFileEvent注册文件事件。之后进入事件循环aeMain。当有文件事件发生时，会调用acceptTcpHandler, 在这里执行anetTcpAccept, 对文件描述符进行读操作。 ","date":"2021-11-08","objectID":"/ae/:2:2","tags":null,"title":"Redis源码-5 异步事件","uri":"/ae/"},{"categories":null,"content":"创建Makefile all: server client @echo \"anet demo\" server : anet.o zmalloc.o ae.o server.o monotonic.o $(CC) -o $@ $^ client : anet.o zmalloc.o client.o $(CC) -o $@ $^ %.o: %.c $(CC) -O0 -DREDIS_TEST=1 -MMD -o $@ -c $\u003c .PHONY: clean clean: rm -rf *.o *.d server client ","date":"2021-11-08","objectID":"/ae/:2:3","tags":null,"title":"Redis源码-5 异步事件","uri":"/ae/"},{"categories":null,"content":"输出 同Redis源码-3 网络编程 ","date":"2021-11-08","objectID":"/ae/:2:4","tags":null,"title":"Redis源码-5 异步事件","uri":"/ae/"},{"categories":null,"content":"性能简单压测 为了看下使用事件循环和不使用事件循环的区别，进行简单压测。网络上找了写tcp压测工具，没找到合适的，就自己写个简单的程序。 测试代码 新建 main.go 连接server端，Hello server package main import ( \"fmt\" \"net\" \"os\" ) func main() { Conn(\"localhost:6380\") } func Conn(service string) { // 绑定 tcpAddr, err := net.ResolveTCPAddr(\"tcp\", service) checkError(err) // 连接 conn, err := net.DialTCP(\"tcp\", nil, tcpAddr) checkError(err) //for { // 发送 _, err = conn.Write([]byte(\"Hello server\")) checkError(err) //} conn.Close() } func checkError(err error) { if err != nil { fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) } } 新建 main_test.go 基准测试 package main import \"testing\" func BenchmarkConn(b *testing.B) { for n := 0; n \u003c b.N; n++ { Conn(\"localhost:6380\") } } ","date":"2021-11-08","objectID":"/ae/:2:5","tags":null,"title":"Redis源码-5 异步事件","uri":"/ae/"},{"categories":null,"content":"测试结果 使用异步事件 go test -bench=. goos: linux goarch: amd64 pkg: test cpu: Intel(R) Celeron(R) N4100 CPU @ 1.10GHz BenchmarkConn-4 6278 356108 ns/op PASS ok test 2.264s 不使用异步事件 goos: linux goarch: amd64 pkg: test cpu: Intel(R) Celeron(R) N4100 CPU @ 1.10GHz BenchmarkConn-4 100 10393680 ns/op PASS ok test 1.048s 可见异步编程能提高程序相应速度的。 ","date":"2021-11-08","objectID":"/ae/:2:6","tags":null,"title":"Redis源码-5 异步事件","uri":"/ae/"},{"categories":null,"content":"参考 understanding-the-redis-event-model ae ","date":"2021-11-08","objectID":"/ae/:3:0","tags":null,"title":"Redis源码-5 异步事件","uri":"/ae/"},{"categories":null,"content":"Redis 网络编程 开发一个server和client, client向server发送消息， server输出client内容 ","date":"2021-11-06","objectID":"/anet/:1:0","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"源代码 源码 ","date":"2021-11-06","objectID":"/anet/:2:0","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"准备工作：从redis源码中拷贝代码 cp /home/vagrant/github/server_installer/servers/redis/redis-6.2/src/zmalloc.* . cp /home/vagrant/github/server_installer/servers/redis/redis-6.2/src/anet.* . cp /home/vagrant/github/server_installer/servers/redis/redis-6.2/src/atomicvar.h . cp /home/vagrant/github/server_installer/servers/redis/redis-6.2/src/fmacros.h . ","date":"2021-11-06","objectID":"/anet/:2:1","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"新建server.c #include \"stdio.h\"#include \"anet.h\"#include \"zmalloc.h\"#include \u003csys/socket.h\u003e#include \u003cunistd.h\u003e#include \"sys/socket.h\"#define NET_IP_STR_LEN 46 /* INET6_ADDRSTRLEN is 46, but we need to be sure */ int main() { // 错误信息 char *neterr = zmalloc(10); printf(\"staring...\\n\"); // 端口6380 int serverSocket = anetTcpServer(neterr, 6380,\"*\" , 2); if ( ! neterr ) { printf(\"start err %s \\n\", neterr); return 1; } printf(\"listening...%d \\n\",serverSocket ); while(1){ int cfd; // 错误信息 char* err = zmalloc(20); char cip[NET_IP_STR_LEN]; int cport; cfd = anetTcpAccept(err, serverSocket, cip, sizeof(cip), \u0026cport); if ( cfd == ANET_ERR ) continue; printf(\"accept...%d\\n\",cfd); char buf[1024]; recv(cfd, buf, sizeof(buf), MSG_WAITALL); printf(\"recv from %s:%d %s\\n\",cip, cport, buf); close(cfd); } close(serverSocket); } ","date":"2021-11-06","objectID":"/anet/:2:2","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"新建client.c #include \"stdio.h\"#include \"anet.h\"#include \"zmalloc.h\"#include \u003csys/socket.h\u003e#include \u003cunistd.h\u003e#include \"sys/socket.h\"#define NET_IP_STR_LEN 46 /* INET6_ADDRSTRLEN is 46, but we need to be sure */ int main() { // 错误信息 char *neterr = zmalloc(10); printf(\"staring...\\n\"); int port; port = 6380; char* addr; addr = \"127.0.0.1\"; int fd = anetTcpNonBlockConnect(NULL,addr,port); char * hello = \"hello\"; printf(\"send %s\\n\", hello); send(fd, hello, sizeof(hello),MSG_DONTWAIT ); close(fd); } ","date":"2021-11-06","objectID":"/anet/:2:3","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"新建Makefile文件 all: server client @echo \"anet demo\" server : anet.o zmalloc.o server.o $(CC) -o $@ $^ client : anet.o zmalloc.o client.o $(CC) -o $@ $^ %.o: %.c $(CC) -O0 -DREDIS_TEST=1 -MMD -o $@ -c $\u003c .PHONY: clean clean: rm -rf *.o *.d server client ","date":"2021-11-06","objectID":"/anet/:2:4","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"解释 anet把封装的了socket编程的接口, 原先需要socket, bind, listen, accept , connect等接口封装为很少的接口，屏蔽了一些复杂的参数，开发网络编程更加接近Go、Python等高级语言。 ","date":"2021-11-06","objectID":"/anet/:2:5","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"输出 执行make后会生成client和server, 先启动server，再执行client。 server端输出 staring... listening...3 accept...4 recv from 127.0.0.1:60322 hello client端输出 staring... send hello ","date":"2021-11-06","objectID":"/anet/:2:6","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"使用到的api int anetTcpServer(char *err, int port, char *bindaddr, int backlog); – 创建tcp服务 int anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port); –监听anetTcpServer的网络请求 int anetTcpNonBlockConnect(char *err, const char *addr, int port); – 连接tcp服务 ","date":"2021-11-06","objectID":"/anet/:2:7","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"码字不易，感谢点赞 ","date":"2021-11-06","objectID":"/anet/:2:8","tags":null,"title":"Redis源码-3  网络编程","uri":"/anet/"},{"categories":null,"content":"内容 redis中的内存分配api redis中的原子操作api ","date":"2021-11-05","objectID":"/malloc/:1:0","tags":null,"title":"Redis中的内存分配和原子操作","uri":"/malloc/"},{"categories":null,"content":"源代码 Redis中的内存分配和原子操作 ","date":"2021-11-05","objectID":"/malloc/:2:0","tags":null,"title":"Redis中的内存分配和原子操作","uri":"/malloc/"},{"categories":null,"content":"代码构建 cp /home/vagrant/github/server_installer/servers/redis/redis-6.2/src/zmalloc.* . cp /home/vagrant/github/server_installer/servers/redis/redis-6.2/src/atomicvar.h . zmalloc.c中引用了config.h, 删除掉 新建server.c, 内容如下 #include \"stdio.h\"#include \"atomicvar.h\"#include \"zmalloc.h\"int main(int argc, char **argv){ redisAtomic long long i = 10; atomicIncr(i, 3); printf(\"hello %lld\\n\",i); char *p; p = zmalloc(10); p = \"hello\"; printf(\"hello %s\\n\",p); int accurate; accurate = 10; #ifdef REDIS_TEST zmalloc_test( argc,argv,accurate ); #endif return 0; } 新建Makefile server : zmalloc.o server.o $(CC) -o $@ $^ %.o: %.c $(CC) -DREDIS_TEST=1 -MMD -o $@ -c $\u003c .PHONY: clean clean: rm -rf *.o *.d server 再看一下zmalloc_test的内容 #ifdef REDIS_TEST #define UNUSED(x) ((void)(x)) int zmalloc_test(int argc, char **argv, int accurate) { void *ptr; UNUSED(argc); UNUSED(argv); UNUSED(accurate); printf(\"Malloc prefix size: %d\\n\", (int) PREFIX_SIZE); printf(\"Initial used memory: %zu\\n\", zmalloc_used_memory()); ptr = zmalloc(123); printf(\"Allocated 123 bytes; used: %zu\\n\", zmalloc_used_memory()); ptr = zrealloc(ptr, 456); printf(\"Reallocated to 456 bytes; used: %zu\\n\", zmalloc_used_memory()); zfree(ptr); printf(\"Freed pointer; used: %zu\\n\", zmalloc_used_memory()); return 0; } #endif ","date":"2021-11-05","objectID":"/malloc/:3:0","tags":null,"title":"Redis中的内存分配和原子操作","uri":"/malloc/"},{"categories":null,"content":"输出 hello 13 hello hello Malloc prefix size: 0 Initial used memory: 24 Allocated 123 bytes; used: 160 Reallocated to 456 bytes; used: 480 Freed pointer; used: 24 ","date":"2021-11-05","objectID":"/malloc/:4:0","tags":null,"title":"Redis中的内存分配和原子操作","uri":"/malloc/"},{"categories":null,"content":"解释 对于zmalloc函数，可以直接对应到c标准库里的malloc, realoc, free函数，redis会根据不同的实现调用不同的内存分配库，以实现更好的性能以及更多的功能。因为redis中已经写好测试了，我们就直接调用了。这里面用到了预编译。正常的编译不会把测试函数编译进redis server中的。在编译多c文件中，没有制定如何生成*.o文件。当用上篇文章中的Makefile编译时会提升找不到zmalloc_test的实现。通过查看redis的Makefile, 发现了 %.o: %.c $(CC) -DREDIS_TEST=1 -MMD -o $@ -c $\u003c 里面的MMD是什么含义呢，下面参考文章有详细的解释,这里总结一下 . M 依赖的文件 . MM 去除#include引用的依赖后的依赖 . D 是生成依赖文件，后缀为.d, 所以有MD 和MMD，这里用的MMD linux下原子操作是C11中的封装。 gcc -MM zmalloc.c 输出为：zmalloc.o: zmalloc.c zmalloc.h atomicvar.h ","date":"2021-11-05","objectID":"/malloc/:5:0","tags":null,"title":"Redis中的内存分配和原子操作","uri":"/malloc/"},{"categories":null,"content":"redis zmalloc \u0026 atomic api size_t zmalloc_used_memory(void) – 动态分配内存 void *zmalloc(size_t size)–分配内存 void *zrealloc(void *ptr, size_t size)– 重新分配内存 void zfree(void *ptr) – 释放内存 atomicIncr(var,count) – 原子加 atomicGetIncr(var,oldvalue_var,count) – Get and increment the atomic counter atomicDecr(var,count) – 原子减 atomicGet(var,dstvar) – 原子取 atomicSet(var,value) – 原子设置数 atomicGetWithSync(var,value) – 原子取, 不成功一直循环 atomicSetWithSync(var,value) – 原子设置, 不成功一直循环 ","date":"2021-11-05","objectID":"/malloc/:6:0","tags":null,"title":"Redis中的内存分配和原子操作","uri":"/malloc/"},{"categories":null,"content":"参考 MMD含义 ","date":"2021-11-05","objectID":"/malloc/:7:0","tags":null,"title":"Redis中的内存分配和原子操作","uri":"/malloc/"},{"categories":null,"content":"编译多文件 我们有以下三个文件 file1.c #include \"stdio.h\"#include \"file2.h\" int main(void){ printf(\"%s:%s:%d\\n\", __FILE__, __FUNCTION__, __LINE__); foo(); return 0; } file2.h void foo(void); file2.c #include \u003cstdio.h\u003e#include \"file2.h\" void foo(void) { printf(\"%s:%s:%d \\n\", __FILE__, __FUNCTION__, __LINE__); return; } 执行 gcc file1.c file2.c -o server 生成可执行程序server, 执行./server 我们可以得到以下输出 file1.c:main:5 file2.c:foo:5 这样就可以编译多文件的程序了。linux下还需要make程序来自动化编译等操作。添加Makefile文件 server : file1.o file2.o $(CC) -o $@ $^ .PHONY: clean clean: rm *.o server 执行make, 就能编译程序了。执行make clean 就会删除make产生的临时文件。 Makefile有以下模式 target: require action 其中target时产物，require时生成target的依赖。 action是动作，可以是编译程序的动作，也可能是输出些信息。 上面的例子中target是server, 依赖是file1.o, file2.o。 make会自动*.o 文件执行 cc -c *.c -o *.o 命令。上面例子中执行cc -c file1.c -o file1.o 和 cc -c file2 -o file2.o。$(CC) 是内置变量，linux下会解释成cc。$@是target, $^是require。这样就能生成可执行程序server了。 下面加了个clean, 因为不是真正的文件，需要用.PHONY: clean 说明是伪文件。 ","date":"2021-11-04","objectID":"/compile-multi-file/:1:0","tags":null,"title":"如何编译多文件的c程序","uri":"/compile-multi-file/"},{"categories":null,"content":"参考 如何编译c程序 ","date":"2021-11-04","objectID":"/compile-multi-file/:2:0","tags":null,"title":"如何编译多文件的c程序","uri":"/compile-multi-file/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"}]